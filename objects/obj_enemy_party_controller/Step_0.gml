/// @description Update party state each frame

// --- AI Memory System: Perception ---
// Perceive events from the global event bus (same as individual enemies)
var _bus_size = ds_list_size(global.ai_event_bus);
for (var i = 0; i < _bus_size; i++) {
    var _event = global.ai_event_bus[| i];

    // Self-filtering: ignore events generated by this controller
    if (struct_exists(_event.data, "source") && _event.data.source == id) {
        continue;
    }

    // Check if event is within perception radius
    var _dist = point_distance(x, y, _event.x, _event.y);
    if (_dist <= perception_radius) {
        // Perceived the event, create a memory
        var _memory = {
            type: _event.type,
            x: _event.x,
            y: _event.y,
            timestamp: current_time
        };
        array_push(my_memories, _memory);
    }
}

// --- AI Memory System: Purge Old Memories ---
// Periodically clean up expired memories (every 60 frames for performance)
memory_purge_timer--;
if (memory_purge_timer <= 0) {
    memory_purge_timer = 60; // Reset timer

    var _i = array_length(my_memories) - 1;
    while (_i >= 0) {
        var _mem = my_memories[_i];
        if ((current_time - _mem.timestamp) > memory_ttl) {
            // Memory is expired, remove it
            array_delete(my_memories, _i, 1);
        }
        _i--;
    }
}

// Evaluate weighted decision for patrol vs engage
if (patrol_original_state == PartyState.patrolling || patrol_original_state == PartyState.protecting) {
    var _decision = evaluate_patrol_decision();

    if (_decision == "engage") {
        // Switch to combat if not already
        if (party_state == patrol_original_state) {
            patrol_home_x = x;
            patrol_home_y = y;
            transition_to_state(PartyState.aggressive);
        }

        // Follow the player
        if (instance_exists(obj_player)) {
            var _move_speed = 1.0;
            var _dir = point_direction(x, y, obj_player.x, obj_player.y);
            x += lengthdir_x(_move_speed, _dir);
            y += lengthdir_y(_move_speed, _dir);
        }
    } else {
        // Return to or continue patrol
        if (party_state != patrol_original_state) {
            // Was engaged, now returning
            transition_to_state(patrol_original_state);
            x = patrol_home_x;
            y = patrol_home_y;
        }

        // Continue patrol movement
        if (patrol_original_state == PartyState.patrolling && patrol_path != -1 && path_exists(patrol_path)) {
            // Move along the path
            patrol_position += patrol_speed / path_get_length(patrol_path);

            // Handle looping
            if (patrol_position >= 1) {
                if (patrol_loop) {
                    patrol_position = 0;
                } else {
                    patrol_position = 1;
                    patrol_speed = -patrol_speed; // Reverse direction
                }
            } else if (patrol_position <= 0) {
                patrol_position = 0;
                if (!patrol_loop) {
                    patrol_speed = -patrol_speed; // Reverse direction
                }
            }

            // Update controller position to current path position
            x = path_get_point_x(patrol_path, patrol_position);
            y = path_get_point_y(patrol_path, patrol_position);
        }
    }
}

// Update party state based on current conditions
update_party_state();

// Update decision weights for all party members
for (var i = 0; i < array_length(party_members); i++) {
    var _enemy = party_members[i];
    if (instance_exists(_enemy)) {
        calculate_decision_weights(_enemy);
    }
}
