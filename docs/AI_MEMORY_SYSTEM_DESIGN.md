# AI Memory & Event System Design

## 1. Overview

This document outlines the design for a system that gives enemy AI a "memory" of events occurring in the world. This allows for more dynamic and intelligent behavior, where AI can react to patterns and past events rather than just the immediate situation. The system is built on three core concepts:

1.  **Event Bus**: A global system for broadcasting significant events (e.g., deaths, sounds, major attacks).
2.  **Perception**: A mechanism for AI entities to "sense" nearby events.
3.  **Memory**: A personal, time-limited list of perceived events that an AI can use to inform its decisions.

This system is designed to integrate directly with the existing `Enemy_Party_System` and the individual reactive behaviors outlined in `ENEMY_AI_PATHFINDING_AND_RANGED_BEHAVIOR.md`.

## 2. Core Components

### 2.1. The Event Bus

The event bus is a temporary, frame-by-frame list of all significant AI events that have been broadcast.

*   **Mechanism**: A global `ds_list` named `global.ai_event_bus`.
*   **Management**:
    *   It is created once at game start (e.g., in `obj_game_controller`).
    *   It is **cleared at the end of every frame**. This ensures events are only processed once by listeners.
*   **Event Structure**: An event is a `struct` with a standardized format:
    ```gml
    {
        type: "EnemyDeath", // Enum or String (e.g., EnemyDeath, Noise, MajorThreat)
        x: 150,            // X position where the event occurred
        y: 400,            // Y position where the event occurred
        data: {}           // Optional struct for extra data (e.g., { source: id, damage_type: "fire" })
    }
    ```

*   **Broadcasting Function**: A global script function will be created to add events to the bus.

    **`scr_broadcast_ai_event(type, x, y, data_struct)`**
    ```gml
    /// @function scr_broadcast_ai_event(type, x, y, [data_struct])
    /// @param {String} type         The type of event.
    /// @param {Real} x              The x-coordinate of the event.
    /// @param {Real} y              The y-coordinate of the event.
    /// @param {Struct} [data_struct] Optional data associated with the event.

    function scr_broadcast_ai_event(_type, _x, _y, _data = {}) {
        var _event = {
            type: _type,
            x: _x,
            y: _y,
            data: _data
        };
        ds_list_add(global.ai_event_bus, _event);
    }
    ```

### 2.2. Perception

Perception is the process by which an AI entity becomes aware of an event on the bus.

*   **Mechanism**: In its Step event, an AI will iterate through `global.ai_event_bus`. For each event, it calculates the distance to the event's location.
*   **Perception Radius**: Each AI will have a `perception_radius` variable. If `distance_to(event.x, event.y) <= self.perception_radius`, the AI "perceives" the event.
*   **Self-Filtering**: An AI should ignore events generated by itself.

### 2.3. Memory Storage & TTL

When an AI perceives an event, it stores it as a "memory."

*   **Data Structure**: Each AI that uses this system will have an array to store its memories.
    *   `my_memories = [];`
*   **Memory Structure**: A memory is a struct that includes a timestamp.
    ```gml
    {
        type: "EnemyDeath",
        x: 150,
        y: 400,
        timestamp: current_time // The time the memory was created
    }
    ```
*   **Time-To-Live (TTL)**: Memories must expire to remain relevant.
    *   Each AI will have a `memory_ttl` variable (e.g., `30000` for 30 seconds).
    *   A memory is considered expired if `(current_time - memory.timestamp) > memory_ttl`.
*   **Purging Logic**: To prevent the `my_memories` array from growing infinitely, old memories are purged. This check should run periodically (e.g., every 60 frames) in the Step event, not every frame, for performance.

## 3. GML Implementation Plan

### 3.1. `obj_game_controller`

**Create Event:**
```gml
// Initialize the global event bus
global.ai_event_bus = ds_list_create();
```

**End Step Event:**
```gml
// Clear the event bus at the end of the frame to prepare for the next.
ds_list_clear(global.ai_event_bus);
```

**Game End / Room End Event:**
```gml
// Clean up the ds_list to prevent memory leaks
ds_list_destroy(global.ai_event_bus);
```

### 3.2. `obj_enemy_parent` (or a new parent `obj_thinking_enemy_parent`)

**Create Event:**
```gml
// Memory System Variables
my_memories = [];
perception_radius = 250; // How far this enemy can "hear" events
memory_ttl = 30000;      // 30 seconds
memory_purge_timer = 60; // Check to purge memories every 60 frames
```

**Step Event:**
```gml
// --- Memory System Logic ---

// 1. Perceive Events
var _bus_size = ds_list_size(global.ai_event_bus);
for (var i = 0; i < _bus_size; i++) {
    var _event = global.ai_event_bus[| i];

    // Optional: ignore self-generated events if they have a source ID
    // if (_event.data != {} && struct_exists(_event.data, "source") && _event.data.source == id) {
    //     continue;
    // }

    var _dist = distance_to_point(_event.x, _event.y);
    if (_dist <= perception_radius) {
        // Perceived the event, create a memory
        var _memory = {
            type: _event.type,
            x: _event.x,
            y: _event.y,
            timestamp: current_time
        };
        array_push(my_memories, _memory);
    }
}

// 2. Purge Old Memories (Periodically)
memory_purge_timer--;
if (memory_purge_timer <= 0) {
    memory_purge_timer = 60; // Reset timer

    var _i = array_length(my_memories) - 1;
    while (_i >= 0) {
        var _mem = my_memories[_i];
        if ((current_time - _mem.timestamp) > memory_ttl) {
            // Memory is expired, remove it
            array_delete(my_memories, _i, 1);
        }
        _i--;
    }
}

// --- Decision Making Logic (Example) ---
// This is where the AI would query its own memory list to make decisions.
// e.g., var recent_deaths = count_memories_of_type("EnemyDeath", 10000);
```

### 3.3. `obj_enemy_party_controller`

The party controller will have the same memory system as an individual enemy. It can use this to make strategic, party-wide decisions.

**Step Event (inside `update_party_state` function):**
```gml
// Existing logic...
var _party_health_pct = calculate_party_health_percentage();
// ...

// New Memory-based Logic
var _recent_deaths = 0;
var _death_check_window = 15000; // 15 seconds
for (var i = 0; i < array_length(my_memories); i++) {
    var _mem = my_memories[i];
    if (_mem.type == "EnemyDeath" && (current_time - _mem.timestamp) < _death_check_window) {
        _recent_deaths++;
    }
}

// If 50% or more of the party has died recently, become cautious regardless of HP
if (_recent_deaths >= array_length(party_members) * 0.5) {
    party_state = PartyState.cautious;
}
// If the leader has a memory of a "MajorThreat" event, the whole party could become defensive
// ... etc ...
```

## 4. Example Scenario: Morale Break

1.  A party of 4 Bandits is active. The `obj_enemy_party_controller` is in `aggressive` state.
2.  Player kills Bandit #1. Bandit #1's `Destroy` or `death` script calls `scr_broadcast_ai_event("EnemyDeath", x, y)`.
3.  The Party Controller and the 3 other Bandits are within `perception_radius`. They all perceive the event and add a new `{ type: "EnemyDeath", ... }` memory to their `my_memories` array.
4.  Player kills Bandit #2. Another `EnemyDeath` event is broadcast and stored in the memories of the controller and the 2 remaining Bandits.
5.  In its next Step event, the Party Controller runs its `update_party_state` logic. It checks its memory and finds two `EnemyDeath` memories from the last 15 seconds. This crosses its morale threshold (`_recent_deaths >= array_length(party_members) * 0.5`).
6.  The controller forcibly changes `party_state` to `cautious` or `desperate`.
7.  The two remaining Bandits, now receiving commands based on the new party state, stop their blind assault and switch to more defensive behaviors like holding formation, seeking cover, or retreating.

## 5. Future Expansion

*   **Differentiated Perception**: Create `visual_perception_radius` and `audio_perception_radius` for different event types.
*   **Memory Query Functions**: Create helper scripts like `scr_count_memories(type, time_window)` to simplify AI decision logic.
*   **Event Data**: Utilize the `data` struct in events more thoroughly. An `EnemyDeath` event could include `{ killed_by: "player_arrow" }`, allowing other AI to specifically react to ranged threats.
*   **Positive Events**: Broadcast events like `AllyHealed` or `LeaderBuffed` that could make AI *more* aggressive.
